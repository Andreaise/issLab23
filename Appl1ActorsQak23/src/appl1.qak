/*

 */  
System /* -msglog */ appl1 

Dispatch startcmd   : start( ARG ) 
Dispatch restart    : start( ARG ) 
Dispatch stopcmd    : stop( ARG ) 
Dispatch resumecmd  : resume( ARG ) 

Dispatch stopappl   : stopappl( ARG ) 
Dispatch resumeappl : resumeappl( ARG ) 

//Dispatch cmd        : cmd(MOVE)  
Dispatch stepdone   : stepdone(V)  
Dispatch stepfailed : stepfailed(DURATION, CAUSE)

Request getpath     : getpath( ARG )	
Request isrunning   : isrunning( ARG )
Reply pathamswer    : pathamswer( ARG )
Reply runninganswer : runninganswer( ARG )

Event info          : info(ARG)
Event sonardata     : sonar(DISTANCE)


//Context ctxbasicrobot    ip [host="localhost" port=8020] 
Context ctxall  ip [host="localhost" port=8720]
//ExternalQActor basicrobot context ctxbasicrobot  

/*  
 * ------------------------------------------------------------------
 *  appl 
 * ------------------------------------------------------------------
*/     
QActor appl context ctxall{         
[# 		 
//var NumEdges    = 0
//var StepTime    = 350L
//var basicrobot  = unibo.basicrobot23.Basicrobot23()
//var result      =  true
#]  
//curl -d "{\"msg\":\"msg(start,dispatch,gui,appl,start(ok),1)\"}"
//-H "Content-Type: application/json"
//-X PUT http://localhost:8090/qak/sendMessage

	State s0 initial {	 
		println("&&&  appl ACTIVE ...") 
		//[# NumEdges = 0   #] 
		[#  unibo.basicomm23.utils.Connection.trace=true
			utils.Appl1StateObject.setConfigFilePath("./robotConfig.json");
			unibo.basicomm23.utils.CommUtils.outblue(name + " | init $currentMsg"   ) 
			//delegate("isrunning","obsforpath");    	 
			//delegate("getpath","obsforpath");
		#] 
		//[# subscribeLocalActor("obsforpath") #]	
		
		
		delegate "stopcmd" to consoleobs
		delegate "resumecmd" to consoleobs
		
		delegate "isrunning" to obsforpath
		delegate "getpath" to obsforpath
   	} 
   	Transition t0 whenMsg startcmd -> startboundary

  	State startboundary{  		  
   		[#  utils.Appl1StateObject.initappl(myself, currentMsg) #] 
     	println("startboundary  ") 
     	[#  utils.Appl1StateObject.doStepAsynch() #] 
    	//request basicrobot -m step : step($StepTime)    	
	}   
 	Transition t0 whenMsg stepdone   -> stepok
	              whenMsg stepfailed -> stepko
	              whenMsg stopappl   -> stopped
     
     State stepok{     	
 		delay 300 //to avoid too rapid changes
 		[#  utils.Appl1StateObject.incNSteps()
 			utils.Appl1StateObject.doStepAsynch() 
 		#] 
		//request basicrobot -m step : step($StepTime)
   		updateResource [# "robot-stepdone" #] 	
   		emitlocalstream info : info(robotstepdone) 
     }
  	Transition t0 whenMsg stepdone   -> stepok
	              whenMsg stepfailed -> stepko
	              whenMsg stopappl   -> stopped
      
     
	State stepko {
		println("stepko ") 
		updateResource [# "robot-collision" #] 
		emitlocalstream info : info(robotcollision)
		[#  utils.Appl1StateObject.incNEdges()
			utils.Appl1StateObject.getVr().turnLeft() 
		#] 
		//forward basicrobot -m cmd : cmd(l)
		updateResource [# "robot-turnleft" #] 	
		emitlocalstream info : info(robotturnleft)
        if [# utils.Appl1StateObject.getNEdges() < 4 #] {
        	delay 300 
        	[#  utils.Appl1StateObject.doStepAsynch() #] 
        	//request basicrobot -m step : step($StepTime)       	
        }else { 
        	forward appl -m restart : start(again)  //automsg
        } 
	}
	Transition t0 whenMsg stepdone   -> stepok
	              whenMsg stepfailed -> stepko
	              whenMsg stopappl   -> stopped
	              whenMsg restart    -> consumePreviousStart
	   	 
    	 
    State stopped{
    	println("appl stopped ") 
    }
    Transition t0 whenMsg resumeappl -> resumed 
    
    State resumed{
    	println("appl resumed ") 
    }     
 	Transition t0 whenMsg stepdone   -> stepok  //accordati dopo stopappl
	              whenMsg stepfailed -> stepko

 /*
  * appl RESTARTING 
  */  
     //elimino più click su start
    State consumePreviousStart{ 
    	printCurrentMessage
    }
    Transition t0 whenTime 10 -> waittorestart  
                  whenMsg startcmd -> consumePreviousStart

	//Inizializzo e attendo un nuovo startcmd
    State waittorestart{ 
    	[#  utils.Appl1StateObject.reset() 
     	#]
 		println("waittorestart") 
	}      	 
    Transition t0 whenMsg startcmd -> restart
    
    State restart{ 
    	[#  utils.Appl1StateObject.setIsRunning(true) 
         utils.Appl1StateObject.doStepAsynch() #] 
 		println("restart") 
	}      	 
 	Transition t0 whenMsg stepdone   -> stepok
	              whenMsg stepfailed -> stepko
    
}

/*
--------------------------------------
 consoleobs
--------------------------------------
*/
QActor consoleobs context ctxall{
	[# var Stopped = false #]
	State s0 initial{
		//printCurrentMessage			
	}
	Transition t0 whenMsg  stopcmd   -> handlestop
				  whenMsg  resumecmd -> handleresume
	State handlestop{
		printCurrentMessage
		if[# Stopped #] {
			println("consoleobs: already stopped")
		}else{
			[# Stopped = true #]
			forward appl -m stopappl : stopappl(console)
		}
	}
	Goto s0
	
	State handleresume{
	   if[# Stopped #] { 
	   		forward appl -m resumeappl : resumepappl(console)
	   		[# Stopped = false #]
	   }else{ println("consoleobs: resume ignored")}
	}	
	Goto s0
}

/*
--------------------------------------
 sonarobs
--------------------------------------
*/
QActor sonarobs context ctxall{
	State s0 initial{
		printCurrentMessage			
	}
	Transition t0 whenEvent sonardata -> handleSonarData
	
	
	State handleSonarData{
		printCurrentMessage		
		forward appl -m stopcmd : stop( 0 )
		delay 2000
		forward appl -m resumecmd : resume( 0 )
	}
	Goto ignoreSonarData
				 	
	State ignoreSonarData{
		printCurrentMessage
	}
	Transition t0 whenTime 500 -> s0 whenEvent sonardata -> ignoreSonarData
	
}

/*
--------------------------------------
 obsforpath
--------------------------------------
*/
QActor obsforpath context ctxall{
	[# val path = utils.PathStateObject() #]
  State s0 initial{
	printCurrentMessage		
	subscribeTo appl	
  }
  Goto waitmsgs
  
  State waitmsgs{  	
  	println("obsforpath waiting ...")
  }
  Transition t0 whenRequest isrunning -> handleIsrunning
                whenRequest getpath   -> handlegetpath
                whenEvent   info      -> handleinfo
  
  State handleinfo{
  	printCurrentMessage
  	onMsg( info : info(ARG) ) {
  		[# val move = payloadArg(0) #]
  		println ( "obsforpath handleinfo ${payloadArg(0)} " )
  		[# path.updatePath(  payloadArg(0)  ) #]
  	}
  }
  Goto waitmsgs  
  
  State  handleIsrunning{
  	printCurrentMessage
 	[#  val r = utils.Appl1StateObject.getIsRunning( ) #] 
 	replyTo isrunning with runninganswer : runninganswer(true)
  } 
  Goto waitmsgs  
  
  State  handlegetpath{
  	//printCurrentMessage
  	[# var Curpath = path.getCurrentPath() #]
  	println("obsforpath | current path=$Curpath")
 	replyTo getpath with pathamswer : pathamswer($Curpath)
  }  
  Goto waitmsgs  
}
